diff --git a/gorp_test.go b/gorp_test.go
index 98ea4d3..f73f55d 100644
--- a/gorp_test.go
+++ b/gorp_test.go
@@ -1586,6 +1586,35 @@ func TestColumnFilter(t *testing.T) {
        if inv2.IsPaid {
                t.Error("IsPaid shouldn't have been updated")
        }
+       inv1.Memo = "d"
+       inv1.IsPaid = true
+       _updateColumns(dbmap, func(col *gorp.ColumnMap) bool {
+               return col.ColumnName == "IsPaid"
+       }, inv1)
+
+       inv3 := &Invoice{}
+       inv3 = _get(dbmap, inv3, inv1.Id).(*Invoice)
+       if inv3.Memo != "c" {
+               t.Errorf("Expected column to be updated (%#v)", inv3)
+       }
+       if !inv3.IsPaid {
+               t.Error("IsPaid should now be updated")
+       }
+
+       // classic update should work
+       inv1.Memo = "e"
+       inv1.IsPaid = false
+       _update(dbmap, inv1)
+
+       inv4 := &Invoice{}
+       inv4 = _get(dbmap, inv4, inv1.Id).(*Invoice)
+       if inv4.Memo != "e" {
+               t.Errorf("Expected column to be updated (%#v)", inv4)
+       }
+       if inv4.IsPaid {
+               t.Error("IsPaid should be false again")
+       }
+
 }

 func TestTypeConversionExample(t *testing.T) {
diff --git a/table.go b/table.go
index 5c51390..ae20dd0 100644
--- a/table.go
+++ b/table.go
@@ -26,12 +26,13 @@ type TableMap struct {
        SchemaName     string
        gotype         reflect.Type
        Columns        []*ColumnMap
-       keys           []*ColumnMap
+       keys           []*ColumnMap // primary key column; can be autoIncrement
        indexes        []*IndexMap
        uniqueTogether [][]string
        version        *ColumnMap
        insertPlan     bindPlan
        updatePlan     bindPlan
+       colFilter      ColumnFilter // different column filters lead to different updatePlans
        deletePlan     bindPlan
        getPlan        bindPlan
        dbmap          *DbMap
diff --git a/table_bindings.go b/table_bindings.go
index 5b049a3..34938e6 100644
--- a/table_bindings.go
+++ b/table_bindings.go
@@ -169,8 +169,17 @@ func (t *TableMap) bindInsert(elem reflect.Value) (bindInstance, error) {
 }

 func (t *TableMap) bindUpdate(elem reflect.Value, colFilter ColumnFilter) (bindInstance, error) {
+
+       // we distinguish mereley between
        if colFilter == nil {
+               if t.colFilter != nil {
+                       t.updatePlan = bindPlan{}
+               }
+               t.colFilter = nil
                colFilter = acceptAllFilter
+       } else {
+               t.updatePlan = bindPlan{} // a new bindPlan everytime; since we cannot compare colFilter funcs
+               t.colFilter = colFilter
        }

        plan := &t.updatePlan
